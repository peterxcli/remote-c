# pC. Min-Max Array Transformation

## analysis

最小的應該很簡單了，就是找到 $b$ 中第一個不小於 $a_i$ 的數 $b_j$，輸出 $b_j−a_i$。為了實現高效的查找，由於原本給出的 $a$ 和 $b$ 即是非降的，可以使用二分查找，`c++` 黨亦可使用 `lower_bound` 函數。

難點在找最大，因為原數組 $a$ 和 $b$ 非降，且長度均為 $n$，可以考慮如下思路：

從後向前遍歷，我們任然通過二分找到 $b$ 中第一個不小於 $a_i$ 的數 $b_j$，當第一次發現 $i=j$ 時，則 $a_i$ 到 $a_n$ 必須匹配 $b_i$ 到 $b_n$，此時 $a_i$ 到 $a_n$ 均可與 $b_n$ 相匹配，但由於 $d$ 非負，因此 $a_1$ 到 $a_{i−1}$ 不可能匹配到 $b_i$ 到 $b_n$ 中的任何一個數，記錄此時匹配位置 $lst=i=j$。

下一次再找到 $i=j$ 時直接使 $a_i$ 到 $a_{lst}$ 與 $b_{lst}$ 匹配，而 $a_1$ 到 $a_{i−1}$ 不可能匹配到 $b_i$ 到 $b_{lst}$ 中的任何一個數，再記錄新的 $lst$。直到遍歷到開頭。

綜上所述，反映了分段思想，即通過分段處理來判斷能否匹配、可能匹配的最大值。